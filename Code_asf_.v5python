{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nLeftDriveFM_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nLeftDriveFM_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_6_1, False)\nLeftDriveFM = MotorGroup(LeftDriveFM_motor_a, LeftDriveFM_motor_b)\nLeftDriveB = Motor(Ports.PORT11, GearSetting.RATIO_6_1, False)\nRightDriveFM_motor_a = Motor(Ports.PORT9, GearSetting.RATIO_6_1, False)\nRightDriveFM_motor_b = Motor(Ports.PORT10, GearSetting.RATIO_6_1, False)\nRightDriveFM = MotorGroup(RightDriveFM_motor_a, RightDriveFM_motor_b)\nRightDriveB = Motor(Ports.PORT20, GearSetting.RATIO_6_1, False)\ncontroller_1 = Controller(PRIMARY)\nIntake_motor_a = Motor(Ports.PORT7, GearSetting.RATIO_18_1, False)\nIntake_motor_b = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)\nIntake = MotorGroup(Intake_motor_a, Intake_motor_b)\nCatapult = Motor(Ports.PORT14, GearSetting.RATIO_18_1, False)\ninertial = Inertial(Ports.PORT12)\ninertial2 = Inertial(Ports.PORT13)\nRoller = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_1_left_shoulder_control_motors_stopped = True\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global controller_1_left_shoulder_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # check the buttonL1/buttonL2 status\n            # to control Intake\n            if controller_1.buttonL1.pressing():\n                Intake.spin(FORWARD)\n                controller_1_left_shoulder_control_motors_stopped = False\n            elif controller_1.buttonL2.pressing():\n                Intake.spin(REVERSE)\n                controller_1_left_shoulder_control_motors_stopped = False\n            elif not controller_1_left_shoulder_control_motors_stopped:\n                Intake.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_left_shoulder_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject: Vex Code   \n#\tAuthor: Kenny Petersen\n#\tCreated: 11/1/2022\n#\tConfiguration: Python\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\nimport math\n\n# Begin project code\n\n# Self Correcting Right Turn by taking the averages of both inertial sensors\ndef InertialRight(deg):\n    while ((inertial.rotation(DEGREES) + inertial2.rotation(DEGREES)) / 2) < (deg-20):\n        RightDriveFM.set_velocity(43,PERCENT)\n        RightDriveB.set_velocity(43,PERCENT)\n        LeftDriveFM.set_velocity(43,PERCENT)\n        LeftDriveB.set_velocity(43,PERCENT)\n        RightDriveFM.spin_for(REVERSE,deg,DEGREES,wait=False)\n        RightDriveB.spin_for(REVERSE,deg,DEGREES,wait=False)\n        LeftDriveFM.spin_for(FORWARD,deg,DEGREES,wait=False)\n        LeftDriveB.spin_for(FORWARD,deg,DEGREES,wait=True)\n    #^ does the initial turn basically saying if the sensor is at < the degree you enter, turn to that average\n    RightDriveFM.set_stopping(HOLD)\n    RightDriveB.set_stopping(HOLD)\n    LeftDriveFM.set_stopping(HOLD)\n    LeftDriveB.set_stopping(HOLD)\n    wait(0.1,SECONDS)\n\n    #Self correcting portion, if the reading of both values is more than the entered value, it will turn slowly opposite direction at \n    #7% power of motor to the actual heading you entered\n\n    while ((inertial.rotation(DEGREES) + inertial2.rotation(DEGREES)) / 2) > deg:\n       RightDriveFM.set_velocity(7,PERCENT)\n       RightDriveB.set_velocity(7,PERCENT)\n       LeftDriveFM.set_velocity(7,PERCENT)\n       LeftDriveB.set_velocity(7,PERCENT)\n       RightDriveFM.spin_for(FORWARD,deg,DEGREES,wait=False)\n       RightDriveB.spin_for(FORWARD,deg,DEGREES,wait=False)\n       LeftDriveFM.spin_for(REVERSE,deg,DEGREES,wait=False)\n       LeftDriveB.spin_for(REVERSE,deg,DEGREES,wait=True)\n    RightDriveFM.set_stopping(HOLD)\n    RightDriveB.set_stopping(HOLD)\n    LeftDriveFM.set_stopping(HOLD)\n    LeftDriveB.set_stopping(HOLD)\n    wait(0.1,SECONDS)\n\n    #Example of a Inertial Turn------ InertialRight(90)-----> the reading of the average starts at zero. So since the value is less than deg-20 (90-20), \n    #it will turn to an avg 90* turn. However, since both sensors will be side by side, one may say 92 and the other may be 87. For the next while loop,\n    #since the avg is 89.5 (less than 90), it will move the opposite direction slowly until the new reading is 90 on both averages. \n\n# Self Correcting Left Turn, same as above, except since the turn goes left, it goes in a negative degree turn, Essentially going to only -180.\n# You would still enter a positive degree measurement, however since it turns left, its basically negative in reading. \ndef InertialLeft(deg):\n    while ((inertial.rotation(DEGREES) + inertial2.rotation(DEGREES)) / 2) > -(deg - 20):\n        RightDriveFM.set_velocity(43,PERCENT)\n        RightDriveB.set_velocity(43,PERCENT)\n        LeftDriveFM.set_velocity(43,PERCENT)\n        LeftDriveB.set_velocity(43,PERCENT)\n        RightDriveFM.spin_for(FORWARD,deg,DEGREES,wait=False)\n        RightDriveB.spin_for(FORWARD,deg,DEGREES,wait=False)\n        LeftDriveFM.spin_for(REVERSE,deg,DEGREES,wait=False)\n        LeftDriveB.spin_for(REVERSE,deg,DEGREES,wait=True)\n\n    RightDriveFM.set_stopping(HOLD)\n    RightDriveB.set_stopping(HOLD)\n    LeftDriveFM.set_stopping(HOLD)\n    LeftDriveB.set_stopping(HOLD)\n    wait(0.1,SECONDS)\n    \n    while ((inertial.rotation(DEGREES) + inertial2.rotation(DEGREES)) / 2) < - deg:\n        RightDriveFM.set_velocity(7,PERCENT)\n        RightDriveB.set_velocity(7,PERCENT)\n        LeftDriveFM.set_velocity(7,PERCENT)\n        LeftDriveB.set_velocity(7,PERCENT)\n        RightDriveFM.spin_for(REVERSE,deg,DEGREES,wait=False)\n        RightDriveB.spin_for(REVERSE,deg,DEGREES,wait=False)\n        LeftDriveFM.spin_for(FORWARD,deg,DEGREES,wait=False)\n        LeftDriveB.spin_for(FORWARD,deg,DEGREES,wait=True)\n    RightDriveFM.set_stopping(HOLD)\n    RightDriveB.set_stopping(HOLD)\n    LeftDriveFM.set_stopping(HOLD)\n    LeftDriveB.set_stopping(HOLD)\n    wait(0.1,SECONDS)\n\n# Standard drive forward command where \"s\" stands for power of motor (0-100) and \"d\" stands for degrees for how far\ndef DriveForward(s,d):\n\n    RightDriveFM.set_velocity(s,PERCENT)\n    RightDriveB.set_velocity(s,PERCENT)\n    LeftDriveFM.set_velocity(s,PERCENT)\n    LeftDriveB.set_velocity(s,PERCENT)\n\n    RightDriveFM.spin_for(FORWARD,d,DEGREES,wait=False)\n    RightDriveB.spin_for(FORWARD,d,DEGREES,wait=False)\n    LeftDriveFM.spin_for(FORWARD,d,DEGREES,wait=False)\n    LeftDriveB.spin_for(FORWARD,d,DEGREES,wait=True)\n\n    wait(0.3,SECONDS)\n\n    LeftDriveFM.set_stopping(COAST)\n    LeftDriveB.set_stopping(COAST)\n    RightDriveFM.set_stopping(COAST)\n    RightDriveB.set_stopping(COAST)\n\ndef DriveBack(s,d):\n    RightDriveFM.set_velocity(s,PERCENT)\n    RightDriveB.set_velocity(s,PERCENT)\n    LeftDriveFM.set_velocity(s,PERCENT)\n    LeftDriveB.set_velocity(s,PERCENT)\n\n    RightDriveFM.spin_for(REVERSE,d,DEGREES,wait=False)\n    RightDriveB.spin_for(REVERSE,d,DEGREES,wait=False)\n    LeftDriveFM.spin_for(REVERSE,d,DEGREES,wait=False)\n    LeftDriveB.spin_for(REVERSE,d,DEGREES,wait=True)\n\n    wait(0.3,SECONDS)\n\n    LeftDriveFM.set_stopping(COAST) \n    LeftDriveB.set_stopping(COAST)\n    RightDriveFM.set_stopping(COAST)\n    RightDriveB.set_stopping(COAST)\n\n#This is a standard turn. Sometimes self correcting turns are not necessary\n\ndef TurnLeft(s,d):\n    RightDriveFM.set_velocity(s,PERCENT)\n    RightDriveB.set_velocity(s,PERCENT)\n    LeftDriveFM.set_velocity(s,PERCENT)\n    LeftDriveB.set_velocity(s,PERCENT)\n\n    RightDriveFM.spin_for(FORWARD,d,DEGREES,wait=False)\n    RightDriveB.spin_for(FORWARD,d,DEGREES,wait=False)\n    LeftDriveFM.spin_for(REVERSE,d,DEGREES,wait=False)\n    LeftDriveB.spin_for(REVERSE,d,DEGREES,wait=True)\n\n    wait(0.3,SECONDS)\n\n    LeftDriveFM.set_stopping(COAST) \n    LeftDriveB.set_stopping(COAST)\n    RightDriveFM.set_stopping(COAST)\n    RightDriveB.set_stopping(COAST)\n\ndef TurnRight(s,d):\n    RightDriveFM.set_velocity(s,PERCENT)\n    RightDriveB.set_velocity(s,PERCENT)\n    LeftDriveFM.set_velocity(s,PERCENT)\n    LeftDriveB.set_velocity(s,PERCENT)\n\n    RightDriveFM.spin_for(REVERSE,d,DEGREES,wait=False)\n    RightDriveB.spin_for(REVERSE,d,DEGREES,wait=False)\n    LeftDriveFM.spin_for(FORWARD,d,DEGREES,wait=False)\n    LeftDriveB.spin_for(FORWARD,d,DEGREES,wait=True)\n\n    wait(0.3,SECONDS)\n\n    LeftDriveFM.set_stopping(COAST) \n    LeftDriveB.set_stopping(COAST)\n    RightDriveFM.set_stopping(COAST)\n    RightDriveB.set_stopping(COAST)\n\n\n# This is very much not a turn, rather a \"swerve\" function. This allows for a quick swift movement. \ndef LeftForward(s,d):\n    LeftDriveFM.set_velocity(s,PERCENT)\n    LeftDriveB.set_velocity(s,PERCENT)\n\n    LeftDriveFM.spin_for(FORWARD,d,DEGREES,wait=False)\n    LeftDriveB.spin_for(FORWARD,d,DEGREES,wait=True)\n\ndef LeftBack(s,d):\n    LeftDriveFM.set_velocity(s,PERCENT)\n    LeftDriveB.set_velocity(s,PERCENT)\n\n    LeftDriveFM.spin_for(REVERSE,d,DEGREES,wait=False)\n    LeftDriveB.spin_for(REVERSE,d,DEGREES,wait=True)\n\ndef RightForward(s,d):\n    RightDriveFM.set_velocity(s,PERCENT)\n    RightDriveB.set_velocity(s,PERCENT)\n\n    RightDriveFM.spin_for(FORWARD,d,DEGREES,wait=False)\n    RightDriveB.spin_for(FORWARD,d,DEGREES,wait=True)\n\ndef RightBack(s,d):\n    RightDriveFM.set_velocity(s,PERCENT)\n    RightDriveB.set_velocity(s,PERCENT)\n\n    RightDriveFM.spin_for(REVERSE,d,DEGREES,wait=False)\n    RightDriveB.spin_for(REVERSE,d,DEGREES,wait=True)\n\n#Used in auto to move the roller, where the speed is already set for 100, but uses time for how long to spin\ndef RollerMove(s):\n    Roller.set_velocity(100,PERCENT)\n\n    Roller.spin_for(REVERSE,s,SECONDS,wait=True)\n\n#Used in auto to pick up discs off the floor, where the speed is set to 80, but uses time for how long to spin based on your movement. \ndef IntakeUp(s):\n    Intake.set_velocity(80,PERCENT)\n\n    Intake.spin_for(FORWARD,s,SECONDS,wait=True)\n\n#Resets the value of the sensor after every turn \ndef InertialRESET():\n    inertial.set_rotation(0,DEGREES)\n    inertial2.set_rotation(0,DEGREES)\n\n    inertial.set_heading(0,DEGREES)\n    inertial2.set_heading(0,DEGREES)\n\n#Sample autonomous code, able to allow you to make the autonomous portion more clear. Its simply\n#just a function of autonomous code, in which you enter the function in the autonomous portion.\ndef FarSide():\n    DriveForward(40, 150);\n    RollerMove(0.3);\n    wait(0.1,SECONDS);\n\n\n\n\n\ndef pre_autonomous():\n    # actions to do when the program starts\n    brain.screen.clear_screen()\n    brain.screen.print(\"pre auton code\")\n    #resets the sensor before auton. ALWAYS set the robot in position first, then enter code so its \n    #correctly calibrated \n    inertial.calibrate()\n    inertial2.calibrate()\n\n    wait(1, SECONDS)\n\ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"autonomous code\")\n    # place automonous code here\n\n    #Implements the function \"FarSide():\" from above\n\n    FarSide();\n\ndef driver_control():\n    brain.screen.clear_screen()\n    # place driver control in this while loop\n    while True:\n        #Basic Drive controls on sticks (TankDrive)\n        LeftDriveFM.set_velocity(controller_1.axis3.position(), PERCENT)\n        LeftDriveB.set_velocity(controller_1.axis3.position(), PERCENT)\n        RightDriveFM.set_velocity(controller_1.axis1.position(), PERCENT)\n        RightDriveB.set_velocity(controller_1.axis1.position(), PERCENT)\n\n        LeftDriveFM.spin(FORWARD)\n        LeftDriveB.spin(FORWARD)\n        RightDriveFM.spin(FORWARD)\n        RightDriveB.spin(FORWARD)\n\n        wait(5,MSEC)\n\n        #Sets brake to coast \n        LeftDriveFM.set_stopping(COAST)\n        LeftDriveB.set_stopping(COAST)\n        RightDriveFM.set_stopping(COAST)\n        RightDriveB.set_stopping(COAST)\n\n        #Example button code for a shooting mech. As you hold it or tap a little, it moves\n        if controller_1.buttonR1.pressing():\n            Catapult.spin(FORWARD)\n        \n        #Sets the motor to stop when its not being pressed\n        else:\n            Catapult.stop()\n\n        if controller_1.buttonL1.pressing():\n            Intake.spin(FORWARD)\n\n        elif controller_1.buttonL2.pressing():\n            Intake.spin(REVERSE)\n\n        else:\n            Intake.stop()\n        \n        \n        wait(20, MSEC)\n\n# create competition instance\ncomp = Competition(driver_control, autonomous)\npre_autonomous()\n","textLanguage":"python","rconfig":[{"port":[1,2],"name":"LeftDriveFM","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio6_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[11],"name":"LeftDriveB","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[9,10],"name":"RightDriveFM","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio6_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[20],"name":"RightDriveB","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"Intake","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[7,8],"name":"Intake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false","id":"partner"},"triportSourcePort":22},{"port":[14],"name":"Catapult","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[12],"name":"inertial","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[13],"name":"inertial2","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[3],"name":"Roller","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}